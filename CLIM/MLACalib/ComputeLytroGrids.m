% July 24 2016
% ComputeLytroGrids.m - For each long exposure white image,
% compute the calibrated grid and write out 2 Lenslet Grid Models.  
% This only needs to be run once.
% 
% .grid2.json is a grid model that uses the HOffset and VOffset
% from the calibrated grid, and includes the computed x- and
% y-spacings and rotation from the calibrated grid.  It is of
% exactly the same format as the .grid.json files generated by the
% toolbox.  As such, this grid model can be used with all toolbox
% functions.  It can be passed to either the BuildHexGrid function
% in the toolbox, or SHGeneralBuildHexGrid to return what I call
% the "Epsilon Calibrated Grid."
%
% .gridcent.json is a grid model that contains the above
% information, along with the location of the center lenslet.  This
% allows construction of the calibrated grid with rotation around
% the center, rather than rotation around the origin which is
% performed by the toolbox hex grid build.  This grid model can be
% passed to SHGeneralBuildHexGrid to return the calibrated grid.

function [] = ComputeLytroGrids(WIDir,FilenamePattern)


[FileNames, BasePath] = LFFindFilesRecursive( WIDir, FilenamePattern );

plotit = 0;

WIidsRegexp = regexp(FileNames,'_\d+','match');
WIidsStr = cell(1,length(WIidsRegexp));
for i=1:length(WIidsRegexp)
    %Select last matched expression in the file name (image number) and remove underscore
    if(isempty(WIidsRegexp{i}))
        WIidsStr{i}='Unknown number';
    else
        WIidsStr{i} = WIidsRegexp{i}{end}(2:end);
    end
end

%Load global mlaCalib data of the camera (for all zoom/focus positions).
mlaData = load_mla_calib(WIDir);

%%%%%%%% Run a superloop over all white images.

numWhiteImages = length(FileNames);
imgNumFailed = [];
fprintf('Processing white image metadata     ');
for WhiteImIndex = 1:length(WIidsStr)
    
    if(isempty(WIidsRegexp{WhiteImIndex}))
        WINum = -1;
    else
        WINum = str2num(WIidsStr{WhiteImIndex});
    end
    fprintf('\b\b\b\b\b%5s', WIidsStr{WhiteImIndex});

    try
        %Retrieve metadata of the current white image
        WIMetadata = LFReadMetadata([WIDir '/' FileNames{WhiteImIndex}]);
        Wdim = WIMetadata.master.picture.frameArray.frame.metadata.image.width;
        Hdim = WIMetadata.master.picture.frameArray.frame.metadata.image.height;
        ZoomStep = WIMetadata.master.picture.frameArray.frame.metadata.devices.lens.zoomStep;
        FocusStep = WIMetadata.master.picture.frameArray.frame.metadata.devices.lens.focusStep;
        %Retrieve mlaCalib data corresponding to the zoom and focus of the current white image.
        CalibGridModel = SHBuildCalibGridModel(ZoomStep, FocusStep, mlaData);
    catch
        CalibGridModel = [];
    end
    
    if(~isempty(CalibGridModel))
    %Generate the lenslet grid model from the retrieved mla calibration data for the current white image.
    [CalibLensletGridModelwithCenter, LytroGridCoords] = SHLFBuildCalibGrid(CalibGridModel, Wdim, Hdim);

    % Create filenames for the toolbox LensletGridModel file
    % (grid.json) and the Epsilon Calibrated Grid (grid2.json).
    [fpath , filebase] = fileparts(FileNames{WhiteImIndex});
    jsonfilein      = [ filebase, '.grid.json' ];
    jsonfilecentout = [ filebase, '.gridcent.json' ];
    jsonfileout2    = [ filebase, '.grid2.json' ];
    
    %MLP note : The grid.json from the toolbox calibration is required to write the grid2.json and gridcent.json.
    %The only reason is that the CamInfo data is read from the grid.json.
    %There should be a way to input the CamInfo without having to read it from the grid.json.
    %But for now, MLACalibration of the current white image fails if the grid.json was not already computed (which should not happen anyway).
    if ~exist(fullfile(WIDir,jsonfilein),'file')
        imgNumFailed = [imgNumFailed; WINum];
        continue
    end
    jsonin = LFReadMetadata(fullfile(WIDir,jsonfilein)); % now the toolbox grid model is in jsonin.LensletGridModel;

% Construct the Epislon Calibrated Lenslet Grid model and write
% it out to .grid2.json files.  
% 

% Notice that in LHBuildLensletGridModel, the initial spacings are
% taken as simple distances from finding peaks on the grid.  So
% they start off as actual on a rectangular grid.  Then they are
% "corrected" by dividing by the cosine of the angle.  This is
% equivalent to actual on a rotated grid.  So we will write out the
% the x-spacing given, and the rotated y distance.

% Parameters HOffset and VOffset: HOffset is the x-axis location of
% the first vertical line in the hex grid and VOffset is the y-axis
% location of the first horizontal line in the hex grid.  Question:
% where is "first?" - comments in the toolbox functions used the term
% "upper left."  But the numbers match what's at the origin in x-y
% space, not what's in the upper left of the grid (i.e., not the
% origin in matlab coordinates).  So I will also use this convention.

    jsonout.GeneratedByInfo.mfilename = 'ComputeLytroGrids';
    dd = date;
    jsonout.GeneratedByInfo.time = dd;

% Now write it out.  

    GeneratedByInfo = jsonout.GeneratedByInfo;
    CamInfo = jsonin.CamInfo;
    LensletGridModel = CalibLensletGridModelwithCenter;
    
% Set the GridModelOptions to null because they are not relevant for the new grids.
    GridModelOptions.Orientation = [];
    GridModelOptions.FilterDiskRadiusMult = [];
    GridModelOptions.CropAmt = [];
    GridModelOptions.SkipStep = [];
    GridModelOptions.ApproxLensletSpacing = [];

    LFWriteMetadata(fullfile(WIDir,jsonfilecentout), LFVar2Struct(GeneratedByInfo,GridModelOptions, CamInfo, LensletGridModel));

% now write out Epsilon Calibrated Grids by removing the center information
    LensletGridModelNoCent = LensletGridModel;
    LensletGridModelNoCent = rmfield(LensletGridModelNoCent,'CenterX');
    LensletGridModelNoCent = rmfield(LensletGridModelNoCent,'CenterY');
    clear LensletGridModel;
    LensletGridModel = LensletGridModelNoCent;


    LFWriteMetadata(fullfile(WIDir,jsonfileout2), LFVar2Struct(GeneratedByInfo,GridModelOptions, CamInfo, LensletGridModel));

% Note - if you build a calibrated grid using the
% CalibLensletGridModelwithCenter computed above, and you build the
% same calibrated grid by reading in your .gridcent.json files, you
% will see differences in pixel location on the order of 10^-7.
% This is caused by the precision of the data in the .gridcent.json
% file being less than the precision of the data in matlab as
% CalibLensletGridModelwithCenter is computed.  The following 2 lines
% are simply to build a grid using the read-in data, which has
% round off error, to compare with the native-precision-data-built
% grid.  Taking 

% July 24 - test to make sure that my differences are caused by
% roundoff when writing the files.  Yes, they are.
% jsonindebug = LFReadMetadata(jsonfileout);
% ReadinTestCoords = SHGeneralBuildHexGrid( jsonindebug.LensletGridModel );

% The following line recreates the grid and confirms that the
% output of the grid built with the model is in fact the same as
% the grid created during its derivation.
% TestLytroModel = SHGeneralBuildHexGrid( CalibLensletGridModelwithCenter);


% Visualize the differences between the two grids in the middle of
% the lenslet array; in the lower left corner of the lenslet array;
% and in the upper left corner of the lenslet array

    if plotit == 1,
        
        TBCoords = SHGeneralBuildHexGrid( jsonin.LensletGridModel );  % build the toolbox grid
        
        fprintf('\n');
        figure(1)
        plot(LytroGridCoords(:,:,1), LytroGridCoords(:,:,2), 'g*');
        hold on
        plot(TBCoords(:,:,1), TBCoords(:,:,2), 'm+');
        % plot(TestLytroModel(:,:,1), TestLytroModel(:,:,2), 'bo'); for testing
        hold off
        p = sprintf('White image %d', WINum);
        title(p);
        grid
        text(1640, 1640, 'Green is calibrated; magenta is toolbox');
        axis([1630 1650 1630 1650])

        figure(2)
        plot(LytroGridCoords(:,:,1), LytroGridCoords(:,:,2), 'g*');
        hold on
        plot(TBCoords(:,:,1), TBCoords(:,:,2), 'm+');
        %plot(TestLytroModel(:,:,1), TestLytroModel(:,:,2), 'bo');
        hold off
        p = sprintf('White image %d', WINum);
        title(p);
        grid
        text(30, 30, 'Green is calibrated; magenta is toolbox');
        axis([0 50 0 50])

        figure(3);
        plot(LytroGridCoords(:,:,1), LytroGridCoords(:,:,2), 'g*');
        hold on
        plot(TBCoords(:,:,1), TBCoords(:,:,2), 'm+');
        %plot(TestLytroModel(:,:,1), TestLytroModel(:,:,2), 'bo');
        hold off
        p = sprintf('White image %d', WINum);
        title(p);
        grid
        text(30, 3260, 'Green is calibrated; magenta is toolbox');
        axis([0 50 3230 3280])

    end

    else
        imgNumFailed = [imgNumFailed; WINum];
    end

%%%%%%%% end the superloop

end
fprintf('\n');
if(length(imgNumFailed)==numWhiteImages)
    warning(['None of the calibrated grids could be generated from ' ...
         'metadata in the folder : ' WIDir '.' 10 'Check that this folder contains a mla calib metadata file.']);
elseif(~isempty(imgNumFailed))
    warning(['Error while generating calibrated grids from mla calib metadata ' ...
         'in the folder : ' WIDir '.' 10 'The following images numbers where skipped in white image folder:'...
         10 sprintf('%d\n',imgNumFailed)]);
end

